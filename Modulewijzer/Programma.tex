\section{Course program}
	The course is structured into six lectures. The six lectures take place during the six weeks of the course, but are not necessarily in a one-to-one correspondance with the course weeks. For example, lectures one and two are fairly short and can take place during a single week.

		\subsection{Chapter 1 - statically typed programming languages}
		\paragraph*{Topics}
		\begin{itemize}
			\item What are types?
			\item (\textbf{Advanced}) Typing and semantic rules: how do we read them?
			\item Introduction to Java and C\# (\textbf{advanced}) with type rules and semantics
			\begin{itemize}
				\item Classes
				\item Fields/attributes
				\item Constructor(s), methods, and static methods
				\item Statements, expressions, and primitive types
				\item Arrays
				\item (\textbf{Advanced}) Lambda's
			\end{itemize}
		\end{itemize}
		
		\paragraph*{Homework}\footnote{The solution to all homework is published on Natschool or GitHub}
		\begin{itemize}
			\item Write an example of Python code that would cause a type error in Java/C\#
			\item Given the following semantic and typing rules, write down how we read them; make an example code that uses them
			\item Write a Java/C\# program featuring
			\begin{itemize}
				\item A \texttt{Counter} class;
				\item With a \texttt{count} integer attribute;
				\item With an empty (parameterless) constructor;
				\item With a method \texttt{Reset};
				\item With a method \texttt{Tick};
				\item (\textbf{Advanced}) With a static method/overloaded operator \texttt{Plus} which adds two counters into one;
				\item (\textbf{Advanced}) With a method \texttt{OnTarget} that takes as input a lambda function which will be fired when the counter reaches a given count.
			\end{itemize}
		\end{itemize}
		
		
		
		\subsection{Chapter 2 - reuse through polymorphism}
		
		\paragraph*{Topics}			
		\begin{itemize}
			\item What is code reuse?
			\item Interfaces and implementation
			\item Implicit vs explicit conversion
			\item (\textbf{Advanced}) Implicit and explicit conversion type rules
			\item Runtime type testing
		\end{itemize}
		
		\paragraph*{Homework}
		\begin{itemize}
			\item Write a \texttt{Vehicle} interface with a method \texttt{move} and a method \texttt{loadFuel}; \texttt{loadFuel} accepts a \texttt{Fuel} instance, where \texttt{Fuel} is an interface of your writing; \texttt{move} returns a boolean which is \texttt{true} if there is enough fuel, and \texttt{false} otherwise
			\item Write a concrete class \texttt{Car} and a concrete class \texttt{Gasoline} that implement, respectively, \texttt{Vehicle} and \texttt{Fuel}; the \texttt{Car} checks that the given fuel is indeed \texttt{Gasoline}
			\item Write a concrete class \texttt{Truck} and a concrete class \texttt{Diesel} that implement, respectively, \texttt{Vehicle} and \texttt{Fuel}; the \texttt{Truck} checks that the given fuel is indeed \texttt{Diesel}
			\item Write a concrete class \texttt{Enterprise} and a concrete class \texttt{Dilithium} that implement, respectively, \texttt{Vehicle} and \texttt{Fuel}; the \texttt{Enterprise} checks that the given fuel is indeed \texttt{Dilithium}
			\item Make a program that receives three vehicles, without knowing their concrete type, and moves them (without resorting to conversions) until their fuel is up
		\end{itemize}
		
		\subsection{Chapter 3 - reuse through generics}
		\paragraph*{Topics}			
		\begin{itemize}
			\item (\textbf{Advanced}) Generic parameters
			\item (\textbf{Advanced}) Interfaces and implementation in the presence of generic parameters
			\item (\textbf{Advanced}) Covariance and contravariance in the presence of generic parameters
		\end{itemize}
		
		\paragraph*{Homework}
		\begin{itemize}
			\item (\textbf{Advanced}) Make a \texttt{List<T>} interface with methods \texttt{Length}, \texttt{Iterate}, \texttt{Map}, and \texttt{Filter}
			\item (\textbf{Advanced}) Define the concrete classes \texttt{Node<T>} and \texttt{Empty<T>} both implementing \texttt{List<T>}
			\item (\textbf{Advanced}) Make a \texttt{List<Vehicle>}, fill it with a series of concrete vehicles, and make them all move ten times
		\end{itemize}
		
		
		
		\subsection{Chapter 4 - architectural considerations}
		
		\paragraph*{Topics}			
		\begin{itemize}
			\item Encapsulation
			\item Abstract classes: between interfaces and implementation
			\item Inheritance of classes and abstract classes
		\end{itemize}
		
		\paragraph*{Homework}
		\begin{itemize}
			\item Write an \texttt{Event} abstract class or interface with a method \texttt{perform}; 
			\item Write a \texttt{Timer} class with a method \texttt{tick} and a method \texttt{reset}; \texttt{reset} restarts the timer, while \texttt{tick} makes the timer move forward and returns whether or not the target time has been reached; when the timer reaches the target time, then fire the events in the list of timer responses
			\item Make a \texttt{TrafficLight} class which uses timers to implement red, green, and yellow lights;
			\item (\textbf{Advanced}) Rebuild timers, but this time with lambda's instead of our custom \texttt{Event}.
		\end{itemize}
		
		\subsection{Chapter 5 - yet more architectural considerations}
		\paragraph*{Topics}			
		\begin{itemize}
			\item (\textbf{Advanced}) Composition versus inheritance
			\item (\textbf{Advanced}) Entity/component model
		\end{itemize}
		
		\paragraph*{Homework}
		\begin{itemize}
			\item (\textbf{Advanced}) Make a \texttt{Component} interface;
			\item (\textbf{Advanced}) Make an \texttt{Entity} abstract class which houses a list of components;
			\item (\textbf{Advanced}) Write a \texttt{Car} class that inherits from \texttt{Entity} and which implements all the functionality that you would expect from a car, but with the \textit{Entity-Component} model; you will need to build components for the engine, the wheels, etc. and all that the \texttt{Car} class does is make correct use of these components.
		\end{itemize}
		
		
\section{Extra homework}\footnote{The solution to all homework is published on Natschool or GitHub}
In order to exercise on your own, you can try your hand at a series of extra, smaller assignments.

\begin{enumerate}
	\item Make a for-loop that sums all numbers between two inputs read from the console

	\item Make a (static) function for (1)

	\item Make an \texttt{Interval} class that:
	\begin{itemize}
		\item takes two integers, \texttt{l} and \texttt{u}, as its constructor parameters
		\item has a \texttt{Sum} method that returns the sum of all numbers between \texttt{l} and \texttt{u}
		\item has a \texttt{Product} method that returns the product of all numbers between \texttt{l} and \texttt{u}
	\end{itemize}

	\item Make a \texttt{Person} interface with methods (or properties with only a getter):
	\begin{itemize}
		\item Name
		\item Surname
		\item Age
	\end{itemize}

	\item Make the \texttt{Customer}, \texttt{Student}, \texttt{Teacher} implementations of \texttt{Person}, ensuring that they all get at least three additional methods and attributes over those in (4)

	\item Make a generic \texttt{Number<N>} abstract class, with methods:
	\begin{itemize}
		\item \texttt{Zero} that returns an \texttt{N}
		\item \texttt{One} that returns an \texttt{N}
		\item abstract methods \texttt{Negate}, that takes an \texttt{N} and returns an \texttt{N} (for example \texttt{Negate(1)} return \texttt{-1})
- Plus, Times, DividedBy that all take two N's and returns an N
		\item The non-abstract method \texttt{Minus} that makes use of \texttt{Plus} and \texttt{Negate}
		\item abstract methods \texttt{SmallerThan} and \texttt{Equal}, that take two \texttt{N}'s and return a \texttt{boolean}
		\item The non-abstract methods \texttt{SmallerOrEqual}, \texttt{GreaterThan}, \texttt{GreaterOrEqual}, \texttt{NotEqual}
	\end{itemize}
	
	\item Make a class \texttt{IntNumber} that implements \texttt{Number<int>}
	\item Make a class \texttt{FloatNumber} that implements \texttt{Number<float>}
	\item Try to make a class \texttt{StringNumber} that implements \texttt{Number<string}: how far can you come?
	
	\item Make the class of (3) generic with respect to the type of the parameters \texttt{l} and \texttt{u}; specifically, build a generic class \texttt{Interval<N>} which takes as input two \texttt{N}'s \texttt{l} and \texttt{u}, and also an instance of \texttt{Number<N>}
	
\end{enumerate}
